#!/usr/bin/Rscript
# Copyright (C) 2012 Joel Granados <joel.granados@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

library(getopt)

usage <- function( st=0 )
{
    cat ( "Usage:\n" )
    cat ( paste(commandArgs()[1], "--generate [DNBM|video|signal] OPTIONS\n") )
    cat ( "\nOPTIONS\n" )

    for ( i in 1:dim(optMat)[1] )
        cat ( "  [--",optMat[i,1],"|-",optMat[i,2],"]\n",optMat[i,5], sep="")

    flush.console()
    q(sa="no", st=st)
}

printopts <- function (opts)
{
    optnames = names(opts)
    cat ( rep("=",72),"\n", sep="")
    cat ( "Option structure: \n" )
    for ( i in 1:length(optnames) )
        cat ( "\topts$", optnames[i],": ",opts[[optnames[i]]],"\n",sep="" )
    cat ( rep("=",72),"\n", sep="")
    flush.console()
}

generate.DNBM <- function(opts)
{
    # Create the smoothing gaussian filter.
    if ( opts$msgf_size == 0 )
        G = NULL
    else
        G = makeBrush(  size=opts$msgf_size, sigma=opts$msgf_sigma,
                        shape="gaussian" )

    # Create the lable list
    lablList = list(fg=opts$fglabl, bg=opts$bglabl)

    dnbm = new.DiscNaiveBayesianModel( opts$train_dir, opts$data_dir,
            nbins=opts$bins, nfolds=opts$folds, transform=opts$color_space,
            labls=lablList, G=G)

    dnbm$m.generate(dnbm)

    if ( !file.exists(dnbm$v.outfile) )
        dnbm$m.save(dnbm)

    cat ( "\nThe new model is kept at", dnbm$v.outfile, "\n" )
}

generate.signal <- function(opts)
{
}

generate.video <- function(opts)
{
}

# FIXME: introduce the morphological stuff somehow.
optMat = matrix ( data=c(
"help",      "h",    0, "logical",
        "\tPrints help information\n",

"generate",  "G",    1, "character",
        paste ( "\t[DNBM|video|signal]. This argument is needed.\n",
                "\tDNBM -> Discreate Naive Bayesian Model.\n",
                "\tvideo -> A video of the test images. Depends on ffmpeg\n",
                "\tsignal -> Two dim signal of the mean of test masks.\n" ),

"train_dir", "T",    2, "character",
        "\tPath to training images and csv files. Required with DNBM\n",

"data_dir", "D",    2, "character",
        "\tPath to data images. Required with DNBM\n",

"bins",      "b",    2, "integer",
        "\tNumber of bins to use for the color signal. Default 100.\n",

"folds",     "f",    2, "integer",
        "\tNumber of folds for S-fold error calculation, Default -1.\n",

"color_space","c",   2, "character",
        paste ( "\tColor space in which the calculations are to take place\n",
                "\t[rgb|hsv|CIEXYZ|CIELAB|CIELUV|yCbCr]. Default rgb\n"),

"fglabl",    "F",    2, "character", # Foreground label
        "\tString used in csv files for foreground. Default 'foreground'\n",

"bglabl",    "B",    2, "character", # Background label
        "\tString used in csv files for background. Default 'background'\n",

"model_file","m",    2, "character", # Path were a model is kept.
        "\tPath were required model is stored. Required with video & signal\n",

"vid_output","V",    2, "character", # Output path for video.
        paste ( "\tPath of the ouput video file. Extension will define format\n",
                "\tCommand uses ffmpeg to convert video. Default is video.mp4\n" ),

"msgf_sigma","W",     2, "double",    # Sigma for model gauss filter
        paste ( "\tStandard deviation used to create gaussiand smoothing filter.\n",
                "\tIt is only used in the model calculation. Default is 4\n" ),

"msgf_size", "w",     2, "integer",   # Size for model gauss filter
        paste ( "\tSize of gauss smoothing filter (in pixels).\n",
                "\tIt is only used in the model calculation. Default is 5 pix\n",
                "\t0 avoids using a gaussian smoothing filter\n" ),

"vsgf_sigma","Z",     2, "double",    # Sigma for video gauss filter
        paste ( "\tStandard deviation used to create gaussiand smoothing filter.\n",
                "\tIt is only used in the video generation. Default is .3\n" ),

"vsgf_size", "z",     2, "integer", # Size for video gauss filter
        paste ( "\tSize of gauss smoothing filter (in pixels).\n",
                "\tIt is only used in the video generation. Default is 5 pix\n",
                "\t0 avoids using a gaussian smoothing filter\n" ) ),
    ncol=5, byrow=T )
opts = getopt ( optMat )

# Set the defaults
if (is.null(opts$bins)) {opts$bins=100}
if (is.null(opts$folds)) {opts$folds=-1}
if (is.null(opts$color_space)) {opts$color_space="rgb"}
if (is.null(opts$fglabl)) {opts$fglabl="foreground"}
if (is.null(opts$bglabl)) {opts$bglabl="background"}
if (is.null(opts$msgf_sigma)) {opts$msgf_sigma=.3}
if (is.null(opts$msgf_size)) {opts$msgf_size=5}
if (is.null(opts$vsgf_sigma)) {opts$vsgf_sigma=.3}
if (is.null(opts$vsgf_size)) {opts$vsgf_size=5}
if (is.null(opts$vid_output)) {opts$vid_output=file.path(getwd(), "video.mp4")}

if ( !is.null(opts$help) )
    usage()

if ( is.null(opts$generate) )
{
    cat("=== PLEASE DEFINE THE --generate OPTION ===\n")
    usage(st=1)
}

# Check the dependancies in the options.
if ( opts$generate == "DNBM"
     && (is.null(opts$train_dir) || is.null(opts$data_dir)) )
{
    cat("=== DATA_DIR AND TRAIN_DIR MUST BE DEFINED ===\n")
    usage(st=1)
}

if ( (opts$generate == "signal" || opts$generate == "video")
     && is.null(opts$model_file) )
{
    cat("=== MODEL_FILE MUST BE DEFINED WHEN USING signal OR video  ===\n")
    usage(st=1)
}

# Check to see if R environment has everything.
if ( require(fields) == FALSE || require(EBImage) == FALSE
     || require(digest) == FALSE )
{
    cat("=== R MUST HAVE fields, EBImage and digest INSTALLED ===\n")
    usage(st=1)
}

# Check to see if ffmpeg is installed.
if ( opts$generate == "video" )
{
    res = system("ffmpeg -version", ignore.stderr=T, ignore.stdout=T)
    if ( res != 0 )
    {
        cat("=== THE ffmpeg COMMAND MUST BE INSTALLED ===\n")
        usage(st=1)
    }
}

# Check file system stuff
if ( !is.null(opts$train_dir) && !file.exists(opts$train_dir) )
{
    cat("=== THE", opts$train_dir, "DIRECTORY DOES NOT EXIST ===\n")
    usage(st=1)
}

if ( !is.null(opts$data_dir) && !file.exists(opts$data_dir) )
{
    cat("=== THE", opts$data_dir, "DIRECTORY DOES NOT EXIST ===\n")
    usage(st=1)
}

if ( file.exists(opts$vid_output) )
{
    cat("=== THE", opts$vid_output, "FILE EXISTS. ERASE IT ===\n")
    usage(st=1)
}

if ( !is.null(opts$model_file) && !file.exists(opts$model_file) )
{
    cat("=== THE", opts$model_file, "FILE DOES NOT EXIST ===\n")
    usage(st=1)
}

cmdArgs = commandArgs()
cmdDir = dirname(sub("--file=", "", cmdArgs[grep("--file=", cmdArgs)]))
source(file.path(cmdDir,"common.R"))
source(file.path(cmdDir,"naiveBayes.R"))
source(file.path(cmdDir,"colorTrans.R"))

# FIXME: Should check to see if all the params are in range.

printopts(opts) #print for debugging
if ( opts$generate == "DNBM" ){
    generate.DNBM(opts)
} else if ( opts$generate == "signal" ) {
    generate.signal(opts)
} else if ( opts$generate == "video" ) {
    generate.signal(opts)
} else {
    cat("=== THE", opts$generate, "OPTION IS NOT DEFINED ===\n")
    usage(st=1)
}

q(sa="no", st=0) # Make sure we return 0
